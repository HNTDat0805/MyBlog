{"/MyBlog/about/":{"data":{"-giới-thiệu-bản-thân#👨‍💻 Giới thiệu bản thân":"👨‍💻 Giới thiệu bản thânXin chào! Mình là Hồ Nguyễn Tấn Đạt, hiện đang là sinh viên ngành Công nghệ thông tin tại Đại học HUTECH.\nMình bắt đầu làm quen với lập trình từ những năm đầu đại học và đặc biệt yêu thích Java – một ngôn ngữ mạnh mẽ, rõ ràng và rất phổ biến trong phát triển phần mềm.\nBlog này được mình tạo ra như một nơi chia sẻ kiến thức, kinh nghiệm và hành trình học lập trình, hy vọng có thể giúp ích cho các bạn mới bắt đầu hoặc cùng đam mê với mình.","-học-tập#🎓 Học tập":"🎓 Đại học Công nghệ TP.HCM – HUTECH\n📚 Chuyên ngành: Công nghệ thông tin\n📅 Năm học: 2023 – nay\nTrong quá trình học, mình thường xuyên tham gia các dự án nhỏ như:\nỨng dụng quản lý quán cà phê ☕ Hệ thống bán vé xem phim 🎬 Blog học lập trình 📘 Những dự án này giúp mình hiểu hơn về kiến trúc phần mềm, cơ sở dữ liệu, và teamwork.","-kiến-thức--kỹ-năng#🧠 Kiến thức \u0026amp; Kỹ năng":"Kỹ năng / Ngôn ngữ Mức độ Ghi chú Java ⭐⭐⭐⭐☆ Hiểu rõ cú pháp, hướng đối tượng, và mô hình 3 tầng C# ⭐⭐⭐☆☆ Nắm cơ bản về Windows Form, ADO.NET SQL ⭐⭐⭐⭐☆ Thực hành truy vấn, thiết kế cơ sở dữ liệu HTML / CSS / JS ⭐⭐⭐☆☆ Hiểu về cấu trúc web và giao diện Git \u0026 GitHub ⭐⭐⭐☆☆ Biết dùng để quản lý dự án, làm việc nhóm","-liên-hệ-với-mình#📞 Liên hệ với mình":"📧 tandatnguyenho805@gmail.com\n💼 github.com/HNTDat0805\n✨ “Học lập trình không chỉ để làm việc, mà để hiểu cách thế giới vận hành.”","-quan-điểm-lập-trình#💡 Quan điểm lập trình":"“Code không chỉ là ngôn ngữ của máy tính — mà còn là cách chúng ta tư duy, sáng tạo và kể câu chuyện của mình.”\nMình tin rằng lập trình là hành trình dài, không có điểm dừng. Mỗi bug là một bài học, và mỗi dòng code viết ra là một bước tiến về phía trước.","-sở-thích-cá-nhân#❤️ Sở thích cá nhân":"☕ Uống cà phê và nghe nhạc lofi khi code\n🎮 Chơi game co-op nhẹ nhàng\n📖 Đọc blog về công nghệ và UI/UX\n🧩 Làm project nhỏ để tự rèn luyện"},"title":"Giới thiệu bản thân"},"/MyBlog/posts/bai1_gioi-thieu-java/":{"data":{"":"","1-cài-đặt-và-kiểm-tra#1. Cài Đặt và Kiểm tra":"Đảm bảo bạn đã cài đặt JDK và kiểm tra phiên bản:\njava -version","1-jdk-java-development-kit#1. JDK (Java Development Kit)":"Bộ công cụ dành cho lập trình viên để viết và biên dịch code. Nó chứa trình biên dịch (javac) và môi trường chạy (JRE).","2-bytecode-mã-trung-gian#2. Bytecode (Mã Trung Gian)":"Khi bạn biên dịch file Java (.java), nó tạo ra mã trung gian gọi là Bytecode (file .class). Bytecode này độc lập với hệ điều hành.","2-code-hello-world#2. Code \u0026ldquo;Hello World!\u0026rdquo;":"Tạo một file có tên XinChao.java:\nJava\n// Tên file phải trùng với tên Class: XinChao.java public class XinChao {\n// Phương thức main: Điểm khởi đầu của chương trình public static void main(String[] args) { // System.out.println là lệnh để in ra console System.out.println(\"Xin Chào, Thế Giới Java!\"); // Ví dụ một lệnh đơn giản: int namHienTai = 2024; System.out.println(\"Năm hiện tại: \" + namHienTai); } }","3-chạy-chương-trình-trong-terminalcmd#3. Chạy Chương Trình (Trong Terminal/CMD)":"Biên dịch:\nBash\njavac XinChao.java\rThực thi:\nBash\njava XinChao","3-jvm-java-virtual-machine#3. JVM (Java Virtual Machine)":"JVM là chương trình giả lập máy tính. Chính JVM sẽ đọc và thực thi Bytecode trên bất kỳ hệ điều hành nào nó được cài đặt.\nQuy trình tóm tắt: Code Java → JDK/javac → Bytecode → JVM → Chạy trên mọi nền tảng!","i-java-là-gì-định-nghĩa-cốt-lõi#I. Java Là Gì? Định Nghĩa Cốt Lõi":"Java là ngôn ngữ lập trình hướng đối tượng (OOP), được phát triển bởi James Gosling tại Sun Microsystems. Java nổi tiếng với sự ổn định, mạnh mẽ và khả năng độc lập nền tảng tuyệt đối thông qua triết lý: WORA (Write Once, Run Anywhere).","ii-cơ-chế-wora-bộ-ba-thần-thánh#II. Cơ Chế WORA: Bộ Ba Thần Thánh":"Bí quyết để Java chạy được trên mọi nền tảng (Windows, macOS, Linux,…) mà không cần biên dịch lại mã nguồn là cơ chế thực thi đặc biệt của nó:","iii-đặc-điểm-quan-trọng#III. Đặc Điểm Quan Trọng":"Hướng Đối Tượng (OOP): Tổ chức code theo các đối tượng, giúp code dễ bảo trì và mở rộng. Garbage Collection: Java tự động quản lý bộ nhớ, giải phóng vùng nhớ không còn sử dụng, giúp ngăn chặn lỗi rò rỉ bộ nhớ. Đa Luồng (Multithreading): Hỗ trợ chạy nhiều tác vụ song song, tối ưu hóa hiệu năng.","iv-chương-trình-đầu-tiên-cấu-trúc-cốt-lõi#IV. Chương Trình Đầu Tiên: Cấu Trúc Cốt Lõi":"Mọi chương trình Java độc lập đều bắt đầu tại một phương thức đặc biệt, nơi JVM tìm đến để bắt đầu thực thi: phương thức main.","v-kết-luận#V. Kết Luận":"Bạn đã nắm được sức mạnh cốt lõi của Java: sự kết hợp giữa Bytecode và JVM tạo nên tính độc lập nền tảng, cùng với kiến trúc OOP vững chắc."},"title":"GIỚI THIỆU VỀ JAVA"},"/MyBlog/posts/bai2_cau-truc-co-ban/":{"data":{"":"","1-gói-package#1. Gói (Package)":"Package là cơ chế nhóm các lớp có liên quan với nhau vào một thư mục logic, giúp quản lý và tránh xung đột tên lớp.\n// Dòng đầu tiên trong file phải là khai báo package package com.tencongty.tenproject.models; public class NguoiDung { // Nội dung lớp NguoiDung }","2-lệnh-import#2. Lệnh Import":"Sử dụng import để cho phép bạn sử dụng một lớp từ một Package khác.\n// Import lớp Scanner từ package java.util import java.util.Scanner; public class ViDuImport { public static void main(String[] args) { // Có thể sử dụng Scanner sau khi import Scanner scanner = new Scanner(System.in); System.out.println(\"Nhập tên của bạn:\"); String ten = scanner.nextLine(); } }","cú-pháp-khai-báo-lớp#Cú Pháp Khai Báo Lớp:":"// Khai báo lớp XeHoi public class XeHoi { // Thuộc tính (dữ liệu) String mauSac = \"Đỏ\"; int tocDo = 0; // Phương thức (hành vi) public void tangToc() { tocDo = tocDo + 10; System.out.println(\"Tốc độ hiện tại: \" + tocDo + \" km/h\"); } }","giải-thích-chi-tiết-phương-thức-main#Giải Thích Chi Tiết Phương Thức \u003ccode\u003emain\u003c/code\u003e":"Phương thức public static void main(String[] args) bao gồm các từ khóa quan trọng sau:\nTừ khóa Ý nghĩa public Có thể truy cập công khai từ bất cứ đâu. static Thuộc về Lớp (Class), không cần tạo Đối tượng (Object) để gọi. void Phương thức không trả về giá trị nào sau khi thực thi xong. main Tên hàm tiêu chuẩn mà JVM (Máy ảo Java) tìm kiếm để bắt đầu chương trình.","i-khái-niệm-cốt-lõi-lớp-class-và-đối-tượng-object#I. Khái Niệm Cốt Lõi: Lớp (Class) và Đối Tượng (Object)":"Trong Java, mọi thứ đều được tổ chức bên trong một Lớp (Class).\nLớp (Class): Giống như một bản thiết kế (Blueprint). Nó định nghĩa các thuộc tính (dữ liệu) và phương thức (hành vi) mà các đối tượng sẽ có. Đối Tượng (Object): Là một thể hiện thực tế được tạo ra từ lớp.","ii-phương-thức-chính-the-main-method#II. Phương Thức Chính (The Main Method)":"Phương thức main là điểm khởi đầu, là nơi JVM bắt đầu thực thi code. Nó phải luôn tuân thủ cú pháp sau:\npublic static void main(String[] args) { // Code của chương trình bắt đầu từ đây // Tạo một Đối tượng từ lớp XeHoi XeHoi xeA = new XeHoi(); // Sử dụng từ khóa 'new' để tạo đối tượng System.out.println(\"Xe A ban đầu có màu: \" + xeA.mauSac); // Gọi phương thức của đối tượng xeA.tangToc(); }","iii-quy-tắc-cú-pháp-cơ-bản#III. Quy Tắc Cú Pháp Cơ Bản":"Tuân thủ các quy tắc này là bắt buộc để code Java chạy được:\nPhân Biệt Chữ Hoa/Thường (Case Sensitive): Tên biến, tên lớp phân biệt rõ ràng (ví dụ: Ten và ten là hai thứ khác nhau). Dấu Chấm Phẩy (;): Mọi câu lệnh kết thúc bằng dấu chấm phẩy. Khối Lệnh ({}): Dùng để nhóm các câu lệnh lại với nhau, định nghĩa thân của Class, Phương thức hoặc cấu trúc điều khiển.","iv-tổ-chức-code-gói-package-và-import#IV. Tổ Chức Code: Gói (Package) và Import":"Khi dự án lớn dần, ta cần cơ chế tổ chức code.","quy-tắc-đặt-tên-conventions#Quy Tắc Đặt Tên (Conventions)":"Thành phần Quy ước Ví dụ Lớp (Class) PascalCase TenLopMoi Biến và Phương thức camelCase tenBienCuaToi, tinhTong() Hằng số (Constant) VIẾT_HOA_CÓ_DẤU_GẠCH_DƯỚI MAX_VALUE","v-chú-thích-comments---code-dễ-đọc#V. Chú Thích (Comments) - Code Dễ Đọc":"Chú thích là những dòng code mà JVM bỏ qua, nhưng chúng lại cực kỳ quan trọng đối với khả năng đọc hiểu của code.\nKiểu Chú Thích Cú Pháp Ứng dụng Dòng đơn // Giải thích nhanh một dòng code. Khối /* ... */ Chú thích trên nhiều dòng. Javadoc /** ... */ Tạo tài liệu tự động (Documentation)."},"title":"CẤU TRÚC CƠ BẢN"},"/MyBlog/posts/bai3_bien-kieu-du-lieu/":{"data":{"":"","1-các-kiểu-số-nguyên-integers#1. Các Kiểu Số Nguyên (Integers)":"Các kiểu này dùng để lưu trữ số nguyên (không có phần thập phân).\nKiểu dữ liệu Kích thước Phạm vi giá trị Ứng dụng phổ biến byte 1 byte -128 đến 127 Tiết kiệm bộ nhớ trong mảng lớn. short 2 bytes -32,768 đến 32,767 Ít dùng hơn int. int 4 bytes Khoảng +/- 2 tỷ Kiểu mặc định và phổ biến nhất. long 8 bytes Rất lớn (+/- 9 quintillion) Lưu trữ số lớn (như ID, timestamp). Lưu ý: Khi gán giá trị cho long, nên thêm chữ L hoặc l ở cuối.\nint diemSo = 100; long danSoTheGioi = 8000000000L;","1-gán-giá-trị-assignment#1. Gán Giá Trị (Assignment)":"Sử dụng toán tử = để gán giá trị cho biến.\nint x = 10; x = 20; // Giá trị mới là 20","1-kiểu-chuỗi-string#1. Kiểu Chuỗi (String)":"String là kiểu tham chiếu phổ biến nhất, dùng để lưu trữ chuỗi ký tự, được đặt trong dấu nháy kép (\" “).\nString tenBlog = \"Blog Java\"; String loiChao = \"Chào mừng bạn!\"; // String có thể được nối chuỗi (Concatenation) String thongBao = loiChao + \" Đến với \" + tenBlog;","2-các-kiểu-số-thực-floating-point-numbers#2. Các Kiểu Số Thực (Floating-Point Numbers)":"Các kiểu này dùng để lưu trữ số có phần thập phân.\nKiểu dữ liệu Kích thước Độ chính xác Ứng dụng phổ biến float 4 bytes Đơn (6-7 chữ số) Tiết kiệm bộ nhớ. double 8 bytes Kép (15 chữ số) Kiểu mặc định và chính xác nhất. Lưu ý: Khi gán giá trị cho float, phải thêm chữ F hoặc f ở cuối.\ndouble PI = 3.1415926535; // Mặc định là double float tyGia = 24500.5f; // Bắt buộc phải có 'f'","2-mảng-array#2. Mảng (Array)":"Mảng là một tập hợp các phần tử có cùng kiểu dữ liệu và có kích thước cố định.\n// Khai báo một mảng các số nguyên (int) int[] diemThi = {90, 85, 95}; // Khai báo một mảng các chuỗi (String) String[] danhSachTen = new String[5];","2-ép-kiểu-type-casting#2. Ép Kiểu (Type Casting)":"Ép kiểu là chuyển đổi giá trị từ kiểu dữ liệu này sang kiểu dữ liệu khác. Ép kiểu Ngầm Định (Implicit Casting): Xảy ra tự động khi chuyển từ kiểu nhỏ hơn sang kiểu lớn hơn (không mất mát dữ liệu). Thứ tự: byte → short → int → long → float → double. int a = 100; double b = a; // Implicit: b = 100.0 (tự động)\rÉp kiểu Tường Minh (Explicit Casting): Phải khai báo kiểu dữ liệu đích (có thể gây mất mát dữ liệu). double c = 10.99; int d = (int) c; // Explicit: d = 10 (mất phần thập phân .99)","3-kiểu-ký-tự-character#3. Kiểu Ký Tự (Character)":"Kiểu char dùng để lưu trữ một ký tự đơn, được đặt trong dấu nháy đơn (’ ‘).\nchar diemA = 'A'; char kyTuDacBiet = '$';","3-kiểu-lớpđối-tượng-tự-định-nghĩa-classobject#3. Kiểu Lớp/Đối tượng Tự Định Nghĩa (Class/Object)":"Bất kỳ Class nào bạn tạo ra đều là một kiểu dữ liệu tham chiếu (ví dụ: XeHoi từ Bài 2).\n// Giả sử có Class 'SinhVien' đã được định nghĩa // Tạo một đối tượng (tham chiếu) SinhVien mới SinhVien svMoi = new SinhVien(\"An\", 20); // So sánh đối tượng (so sánh địa chỉ bộ nhớ) SinhVien svKhac = svMoi; // Hai tham chiếu trỏ về cùng một đối tượng","4-interface-giao-diện-và-wrapper-classes#4. Interface (Giao diện) và Wrapper Classes":"Interface (Giao diện): Dùng để tham chiếu đến các đối tượng triển khai giao diện đó. Ví dụ: List, Map.\nWrapper Classes: Các lớp bao bọc (Object) cho các kiểu nguyên thủy, dùng khi cần xử lý kiểu nguyên thủy như một đối tượng (ví dụ: trong các Collection).","4-kiểu-logic-boolean#4. Kiểu Logic (Boolean)":"Kiểu boolean chỉ có hai giá trị: true hoặc false, dùng cho logic điều kiện.\nboolean laSinhVien = true; boolean coLoi = false;","cú-pháp-khai-báo-biến#Cú Pháp Khai Báo Biến":"Cú pháp cơ bản bao gồm Kiểu Dữ Liệu và Tên Biến:\n// Cú pháp: [Kiểu Dữ Liệu] [Tên Biến]; int soLuong; // Khai báo và gán giá trị ban đầu (Initialization) String tenHocSinh = \"Nguyễn Văn A\";","i-biến-variables-là-gì#I. Biến (Variables) Là Gì?":"Biến là một vùng nhớ được đặt tên trong bộ nhớ máy tính, dùng để lưu trữ dữ liệu.","ii-kiểu-dữ-liệu-nguyên-thủy-primitive-data-types#II. Kiểu Dữ Liệu Nguyên Thủy (Primitive Data Types)":"Java có 8 kiểu dữ liệu nguyên thủy cơ bản, chúng được dùng để lưu trữ các giá trị đơn lẻ và có kích thước cố định trong bộ nhớ.","iii-kiểu-dữ-liệu-tham-chiếu-reference-data-types#III. Kiểu Dữ Liệu Tham Chiếu (Reference Data Types)":"Không giống như kiểu nguyên thủy, kiểu tham chiếu không lưu trữ trực tiếp giá trị mà lưu trữ địa chỉ (tham chiếu) đến đối tượng trong bộ nhớ.\nVí dụ: String, Array, Class, Interface.","iv-quy-tắc-gán-giá-trị-assignment-và-ép-kiểu-casting#IV. Quy Tắc Gán Giá Trị (Assignment) và Ép Kiểu (Casting)":"","v-tổng-kết-lưu-trữ-hiệu-quả#V. Tổng Kết: Lưu Trữ Hiệu Quả":"Việc chọn kiểu dữ liệu phù hợp giúp tối ưu hóa bộ nhớ và độ chính xác của chương trình."},"title":"BIẾN VÀ KIỂU DỮ LIỆU"},"/MyBlog/posts/bai4_cau-truc-dieu-khien/":{"data":{"":"","1-if-else-if-và-else#1. \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse if\u003c/code\u003e, và \u003ccode\u003eelse\u003c/code\u003e":"Dùng để thực thi một khối code nếu một điều kiện cụ thể là true.\nint diemSo = 75; if (diemSo \u003e= 90) { System.out.println(\"Hạng A\"); } else if (diemSo \u003e= 70) { System.out.println(\"Hạng B\"); } else { System.out.println(\"Hạng C\"); }","1-vòng-lặp-for#1. Vòng Lặp for":"Thích hợp khi bạn biết chính xác số lần lặp.\nCấu trúc gồm 3 phần: Khởi tạo; Điều kiện lặp; Bước tăng/giảm.\n// Lặp 5 lần, từ i=0 đến i=4 for (int i = 0; i \u003c 5; i++) { System.out.println(\"Lặp lần thứ: \" + i); }","2-switch#2. switch":"Dùng khi bạn có nhiều trường hợp (case) so sánh với cùng một biến. Lệnh break là bắt buộc để thoát khỏi khối switch sau khi thực thi xong một case.\nint ngay = 3; String tenNgay; switch (ngay) { case 1: tenNgay = \"Chủ Nhật\"; break; case 3: tenNgay = \"Thứ Ba\"; break; default: tenNgay = \"Ngày Không Hợp Lệ\"; } System.out.println(\"Hôm nay là: \" + tenNgay);","2-vòng-lặp-while#2. Vòng Lặp while":"Lặp liên tục miễn là điều kiện còn đúng (true). Rất quan trọng là phải có một bước thoát bên trong khối lệnh.\nint dem = 0; while (dem \u003c 3) { System.out.println(\"Giá trị đếm: \" + dem); dem++; // Bước thoát: đảm bảo vòng lặp dừng lại }","3-vòng-lặp-do-while#3. Vòng Lặp do-while":"Khối lệnh được thực thi ít nhất một lần, sau đó mới kiểm tra điều kiện lặp.\nint i = 10; do { System.out.println(\"Chạy ít nhất một lần (vì i = 10)\"); i++; } while (i \u003c 5); // Điều kiện này sai ngay lần đầu, nhưng khối lệnh vẫn chạy 1 lần","i-mở-đầu-đưa-ra-quyết-định#I. Mở Đầu: Đưa Ra Quyết Định":"Cấu trúc Điều khiển giúp kiểm soát luồng thực thi của chương trình, cho phép ra quyết định (chọn nhánh thực thi) và lặp lại (thực hiện một khối lệnh nhiều lần) tùy theo điều kiện cụ thể.","ii-câu-lệnh-điều-kiện-conditional-statements#II. Câu Lệnh Điều Kiện (Conditional Statements)":"","iii-vòng-lặp-loops---lặp-lại-hành-động#III. Vòng Lặp (Loops) - Lặp Lại Hành Động":"","iv-lệnh-điều-khiển-vòng-lặp#IV. Lệnh Điều Khiển Vòng Lặp":"Đây là các lệnh dùng để thay đổi luồng hoạt động của vòng lặp:\nLệnh Ý nghĩa break Thoát hoàn toàn khỏi vòng lặp hiện tại. continue Bỏ qua lần lặp hiện tại và chuyển sang lần lặp tiếp theo. for (int j = 1; j \u003c= 5; j++) { if (j == 3) { continue; // Khi j=3, bỏ qua lệnh in và nhảy sang j=4 } if (j == 5) { break; // Khi j=5, thoát hoàn toàn khỏi vòng lặp } System.out.println(\"Giá trị: \" + j); // Chỉ in ra 1, 2, 4 }","v-kết-luận#V. Kết Luận":"Cấu trúc điều khiển là nền tảng của mọi logic phức tạp. Nắm vững các cấu trúc này giúp bạn tạo ra các chương trình thông minh hơn."},"title":"CẤU TRÚC ĐIỀU KHIỂN"},"/MyBlog/posts/bai5_mang-va-chuoi/":{"data":{"":"","1-khai-báo-chuỗi#1. Khai Báo Chuỗi":"// Cách 1: Dùng String Literal (phổ biến) String ten = \"John Doe\"; // Cách 2: Dùng từ khóa new (tạo đối tượng mới trong bộ nhớ) String thongDiep = new String(\"Xin chào\");","1-khai-báo-và-khởi-tạo-mảng#1. Khai Báo và Khởi Tạo Mảng":"Có hai cách chính để tạo mảng:\n// Cách 1: Khởi tạo với kích thước cố định (Kích thước: 5) // Các phần tử sẽ được gán giá trị mặc định (0 cho int, null cho String,...) int[] soNguyen = new int[5]; // Cách 2: Khởi tạo trực tiếp với các giá trị (Kích thước: 3) String[] tenTraiCay = {\"Táo\", \"Cam\", \"Xoài\"};","2-các-phương-thức-methods-thường-dùng#2. Các Phương Thức (Methods) Thường Dùng":"Lớp String cung cấp nhiều phương thức mạnh mẽ để thao tác và kiểm tra chuỗi.\nPhương thức Công dụng Ví dụ .length() Trả về độ dài của chuỗi. \"Hello\".length() → 5 .charAt(index) Lấy ký tự tại chỉ số cụ thể. \"Java\".charAt(1) → 'a' .substring(start) Trích xuất chuỗi con từ chỉ số start. \"Code\".substring(2) → \"de\" .equals(other) So sánh giá trị chuỗi (phân biệt hoa thường). \"A\".equals(\"a\") → false .equalsIgnoreCase(other) So sánh giá trị chuỗi (không phân biệt hoa thường). \"A\".equalsIgnoreCase(\"a\") → true .toUpperCase() Chuyển chuỗi sang chữ hoa. \"hi\".toUpperCase() → \"HI\" .trim() Loại bỏ khoảng trắng ở đầu và cuối chuỗi. \" hello \".trim() → \"hello\"","2-truy-cập-và-gán-giá-trị#2. Truy Cập và Gán Giá Trị":"Phần tử trong mảng được truy cập thông qua chỉ số (index).\nint[] diemSo = {8, 9, 7}; // Lấy giá trị phần tử thứ nhất (index 0) int diemDauTien = diemSo[0]; // diemDauTien = 8 // Gán giá trị mới cho phần tử cuối cùng (index 2) diemSo[2] = 10; // Lấy kích thước của mảng int kichThuoc = diemSo.length; // kichThuoc = 3","3-so-sánh-chuỗi-quan-trọng#3. So Sánh Chuỗi (Quan trọng)":"Luôn dùng phương thức .equals() để so sánh nội dung của hai chuỗi, không dùng toán tử ==. Toán tử == chỉ so sánh địa chỉ bộ nhớ (tham chiếu), không phải giá trị.\nString s1 = \"Java\"; String s2 = new String(\"Java\"); String s3 = \"Java\"; System.out.println(s1 == s2); // false (Địa chỉ khác nhau) System.out.println(s1.equals(s2)); // true (Giá trị giống nhau) System.out.println(s1 == s3); // true (Do Java tối ưu hóa String Literal, cùng địa chỉ)","3-vòng-lặp-với-mảng#3. Vòng Lặp Với Mảng":"Sử dụng vòng lặp for truyền thống hoặc for-each để duyệt qua các phần tử.\nString[] mauSac = {\"Đỏ\", \"Xanh\", \"Vàng\"}; // Duyệt bằng for-each (Dễ đọc hơn) for (String mau : mauSac) { System.out.println(mau); } // Duyệt bằng for truyền thống (Dùng khi cần dùng index) for (int i = 0; i \u003c mauSac.length; i++) { System.out.println(\"Màu thứ \" + i + \": \" + mauSac[i]); }","4-mảng-đa-chiều-multidimensional-arrays#4. Mảng Đa Chiều (Multidimensional Arrays)":"Thường dùng là mảng hai chiều, giống như một bảng (table) hoặc ma trận (Matrix).\n// Mảng 2x3 (2 hàng, 3 cột) int[][] maTran = { {1, 2, 3}, // Hàng 0 {4, 5, 6} // Hàng 1 }; // Truy cập phần tử ở Hàng 1, Cột 0 (Giá trị 4) int phanTu = maTran[1][0];","i-mảng-arrays#I. Mảng (Arrays)":"Mảng là một tập hợp các biến có cùng kiểu dữ liệu, được lưu trữ liên tiếp nhau trong bộ nhớ. Mảng có kích thước cố định và các phần tử được truy cập thông qua chỉ số (index), bắt đầu từ 0.","ii-chuỗi-string#II. Chuỗi (String)":"String là một lớp (Class) và là một kiểu dữ liệu tham chiếu trong Java, được dùng để lưu trữ một chuỗi các ký tự. Chuỗi trong Java là bất biến (Immutable), nghĩa là không thể thay đổi sau khi đã được tạo.","iii-kết-luận#III. Kết Luận":"Mảng cung cấp cách lưu trữ có cấu trúc, còn String là công cụ không thể thiếu để xử lý văn bản."},"title":"MẢNG VÀ CHUỖI"},"/MyBlog/posts/bai6_lap-trinh-huong-doi-tuong/":{"data":{"":"","1-class-và-object-ôn-lại#1. Class và Object (Ôn lại)":"Lớp (Class): Một bản thiết kế (Blueprint) định nghĩa cấu trúc của các đối tượng. Đối Tượng (Object): Một thể hiện thực tế của Lớp, chứa dữ liệu (trạng thái) và hành vi (phương thức). // Lớp (Class) public class DongVat { String ten; // Thuộc tính // Phương thức public void keu() { System.out.println(\"Động vật đang kêu.\"); } } // Tạo Đối tượng (Object) trong phương thức main public static void main(String[] args) { // meoA là một Đối tượng của lớp DongVat DongVat meoA = new DongVat(); meoA.ten = \"Kitty\"; meoA.keu(); // Kết quả: Động vật đang kêu. }","1-đóng-gói-encapsulation#1. Đóng Gói (Encapsulation)":"Khái niệm: Là cơ chế buộc dữ liệu (thuộc tính) và code (phương thức) lại với nhau thành một đơn vị duy nhất (Class).\nMục đích: Ẩn chi tiết triển khai (implementation details) khỏi người dùng. Dữ liệu thường được khai báo là private và chỉ được truy cập thông qua các phương thức public (Getter/Setter).\npublic class TaiKhoan { private double soDu; // Thuộc tính private (Đóng gói) // Getter (Truy cập dữ liệu) public double getSoDu() { return soDu; } // Setter (Thay đổi dữ liệu có kiểm soát) public void setSoDu(double soTien) { if (soTien \u003e 0) { this.soDu = soTien; } } }","2-kế-thừa-inheritance#2. Kế Thừa (Inheritance)":"Khái niệm: Cho phép một lớp (lớp con, Subclass) kế thừa các thuộc tính và phương thức từ một lớp khác (lớp cha, Superclass).\nMục đích: Tái sử dụng code và tạo mối quan hệ “là một” (Is-a relationship). Dùng từ khóa extends.\n// Lớp cha public class HinhHoc { public void ve() { System.out.println(\"Vẽ hình học.\"); } } // Lớp con kế thừa từ HinhHoc public class HinhTron extends HinhHoc { // HinhTron tự động có phương thức ve() của lớp cha }","3-đa-hình-polymorphism#3. Đa Hình (Polymorphism)":"Khái niệm: Nghĩa là “đa dạng hình thái”. Cho phép một hành vi (phương thức) có thể được thực hiện theo nhiều cách khác nhau. Ví dụ phổ biến:\nOverloading (Nạp chồng phương thức):Nhiều phương thức cùng tên nhưng khác tham số.\nOverriding (Ghi đè phương thức): Lớp con định nghĩa lại phương thức của lớp cha.","4-trừu-tượng-abstraction#4. Trừu Tượng (Abstraction)":"Khái niệm: Chỉ hiển thị những thông tin cần thiết và ẩn đi những chi tiết phức tạp, không liên quan.\nThực hiện: Thông qua Abstract Classes (Lớp Trừu Tượng) và Interfaces (Giao diện).","i-oop-là-gì-tư-duy-lập-trình-mới#I. OOP Là Gì? Tư Duy Lập Trình Mới":"Lập trình Hướng Đối Tượng (Object-Oriented Programming - OOP) là một mô hình lập trình dựa trên khái niệm Đối tượng (Object), trong đó dữ liệu (thuộc tính) và code (phương thức) được đóng gói lại với nhau.\nOOP là nền tảng quan trọng nhất của Java, giúp chúng ta mô hình hóa các thực thể trong thế giới thực vào code, làm cho chương trình trở nên dễ quản lý, linh hoạt và tái sử dụng hơn.","ii-bốn-trụ-cột-cơ-bản-của-oop#II. Bốn Trụ Cột Cơ Bản của OOP":"Bốn nguyên tắc chính làm nên sức mạnh của OOP:","iii-tóm-tắt-vai-trò#III. Tóm Tắt Vai Trò":"Trụ cột Mục đích chính Cơ chế trong Java Đóng Gói Bảo vệ và kiểm soát dữ liệu. private variables, public Getter/Setter. Kế Thừa Tái sử dụng code, tạo cấu trúc phân cấp. Từ khóa extends. Đa Hình Linh hoạt, cho phép một giao diện nhiều triển khai. Overloading, Overriding. Trừu Tượng Đơn giản hóa sự phức tạp, tập trung vào chức năng. abstract class, interface.","iv-kết-luận#IV. Kết Luận":"OOP là trọng tâm của Java. Nắm vững bốn trụ cột này là chìa khóa để viết code chuyên nghiệp, dễ bảo trì."},"title":"LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG - OOP"},"/MyBlog/posts/bai7_xu-ly-ngoai-le/":{"data":{"":"","1-khối-try-catch-finally#1. Khối \u003ccode\u003etry-catch-finally\u003c/code\u003e":"Đây là cấu trúc cơ bản để quản lý ngoại lệ:\ntry: Chứa đoạn code có khả năng sinh ra lỗi. catch: Bắt và xử lý loại ngoại lệ cụ thể nếu lỗi xảy ra. finally: Khối code luôn luôn được thực thi, dù ngoại lệ có xảy ra hay không (thường dùng để dọn dẹp tài nguyên). try { // Code có thể gây lỗi (ví dụ: chia cho 0) int ketQua = 10 / 0; System.out.println(ketQua); } catch (ArithmeticException e) { // Bắt và xử lý ngoại lệ chia cho 0 System.out.println(\"Lỗi: Không thể chia cho 0.\"); } finally { // Luôn chạy System.out.println(\"Quá trình tính toán kết thúc.\"); }","1-lớp-file#1. Lớp File":"Lớp java.io.File được dùng để đại diện cho một tệp hoặc thư mục trong hệ thống, chứ không phải nội dung bên trong tệp.\nimport java.io.File; // Tạo đối tượng đại diện cho tệp 'data.txt' File tep = new File(\"data.txt\"); // Các phương thức cơ bản boolean tonTai = tep.exists(); boolean daTao = tep.createNewFile(); // Tạo tệp mới","2-các-loại-ngoại-lệ-chính#2. Các Loại Ngoại Lệ Chính":"Java phân loại ngoại lệ thành ba nhóm chính, tất cả đều là các lớp con của Throwable:\nLoại Ngoại Lệ Mô tả Bắt buộc xử lý? Ví dụ phổ biến Checked Lỗi có thể phục hồi, thường liên quan đến môi trường bên ngoài (tệp, mạng). Bắt buộc (try-catch hoặc throws). IOException, SQLException Unchecked Lỗi lập trình (logic sai, dữ liệu không hợp lệ). Không bắt buộc (Nên sửa code). NullPointerException, ArithmeticException Error Lỗi nghiêm trọng ngoài tầm kiểm soát của ứng dụng. Không (Không thể phục hồi). OutOfMemoryError, StackOverflowError","2-đọc-dữ-liệu-từ-tệp#2. Đọc Dữ Liệu từ Tệp":"Thường dùng lớp Scanner (cho văn bản đơn giản) hoặc BufferedReader (cho hiệu suất cao).\nimport java.io.File; import java.util.Scanner; try { File myObj = new File(\"ten_tep.txt\"); Scanner myReader = new Scanner(myObj); while (myReader.hasNextLine()) { String data = myReader.nextLine(); System.out.println(data); } myReader.close(); } catch (FileNotFoundException e) { System.out.println(\"Không tìm thấy tệp.\"); }","3-ghi-dữ-liệu-vào-tệp#3. Ghi Dữ Liệu vào Tệp":"Thường dùng lớp FileWriter hoặc PrintWriter.\nimport java.io.FileWriter; import java.io.IOException; try { // Tham số 'true' nghĩa là ghi tiếp (append), nếu là 'false' sẽ ghi đè FileWriter writer = new FileWriter(\"ten_tep_ghi.txt\", true); writer.write(\"Thêm dòng mới vào tệp.\\n\"); writer.close(); // Quan trọng: Phải đóng tài nguyên System.out.println(\"Ghi tệp thành công.\"); } catch (IOException e) { System.out.println(\"Xảy ra lỗi khi ghi tệp.\"); }","3-từ-khóa-throws#3. Từ Khóa throws":"Dùng để ủy quyền việc xử lý ngoại lệ cho phương thức gọi nó. Chỉ sử dụng cho Checked Exceptions.\n// Phương thức này thông báo nó có thể ném ra IOException public void docTep() throws IOException { // Giả sử code đọc tệp ở đây throw new IOException(\"Không tìm thấy tệp.\"); }","i-xử-lý-ngoại-lệ-exception-handling#I. Xử Lý Ngoại Lệ (Exception Handling)":"Khi chương trình gặp lỗi trong quá trình thực thi, Java sinh ra ngoại lệ (Exception). Xử lý ngoại lệ là kỹ thuật giúp chương trình không bị dừng đột ngột (crash).","ii-làm-việc-với-tệp-file-io#II. Làm Việc Với Tệp (File I/O)":"I/O (Input/Output) là quá trình chương trình tương tác với thế giới bên ngoài (tệp, mạng, console).","iii-kết-luận#III. Kết Luận":"Xử lý ngoại lệ là bắt buộc để tạo ra các chương trình ổn định. Làm việc với tệp mở ra cánh cửa để chương trình tương tác với dữ liệu bên ngoài."},"title":"XỬ LÝ NGOẠI LỆ"},"/MyBlog/posts/bai8_lap-trinh-socket/":{"data":{"":"","1-lớp-serversocket#1. Lớp \u003ccode\u003eServerSocket\u003c/code\u003e":"Lớp này dùng để tạo một Server Socket. Nó lắng nghe các yêu cầu kết nối từ Client trên một cổng (Port) cụ thể.\nimport java.net.ServerSocket; import java.net.Socket; import java.io.IOException; public class ServerCoBan { public static void main(String[] args) { int port = 6666; // Cổng lắng nghe try (ServerSocket serverSocket = new ServerSocket(port)) { System.out.println(\"Server đang lắng nghe trên cổng \" + port); // serverSocket.accept() là lệnh chặn, chờ Client kết nối Socket clientSocket = serverSocket.accept(); System.out.println(\"Client đã kết nối từ: \" + clientSocket.getInetAddress()); // Sau khi kết nối, Server và Client trao đổi dữ liệu qua clientSocket // ... (Code xử lý Input/Output) } catch (IOException e) { e.printStackTrace(); } } }","1-lớp-socket#1. Lớp Socket":"Lớp này được dùng để tạo một Socket Client. Nó cần địa chỉ IP hoặc tên máy chủ, và số cổng của máy chủ.\nimport java.net.Socket; import java.io.IOException; public class ClientCoBan { public static void main(String[] args) { String serverAddress = \"localhost\"; // Địa chỉ máy chủ (có thể là IP) int port = 6666; try (Socket socket = new Socket(serverAddress, port)) { System.out.println(\"Đã kết nối tới Server: \" + serverAddress + \":\" + port); // Gửi dữ liệu đến Server (OutputStream) socket.getOutputStream().write(\"Xin chào Server!\".getBytes()); // Nhận dữ liệu từ Server (InputStream) // ... (Code đọc dữ liệu) } catch (IOException e) { System.out.println(\"Không thể kết nối tới Server.\"); e.printStackTrace(); } } }","2-xử-lý-dữ-liệu-trên-server#2. Xử lý Dữ liệu trên Server":"Để gửi và nhận dữ liệu, chúng ta sử dụng các luồng I/O (Input/Output Streams) tương tự như làm việc với tệp.\nLớp Mục đích InputStream Nhận dữ liệu từ Client. OutputStream Gửi dữ liệu đến Client.","i-giới-thiệu-lập-trình-mạng-và-socket#I. Giới Thiệu Lập Trình Mạng và Socket":"Java hỗ trợ mạnh mẽ lập trình mạng thông qua Socket API.\nSocket: Là điểm cuối (endpoint) của một kết nối giao tiếp hai chiều (two-way communication link) giữa hai chương trình chạy trên mạng. TCP (Transmission Control Protocol): Là giao thức phổ biến nhất được sử dụng bởi Java Socket, đảm bảo dữ liệu được truyền đi đáng tin cậy và theo đúng thứ tự (Connection-Oriented).","ii-phía-máy-chủ-server#II. Phía Máy Chủ (Server)":"Máy chủ phải chờ và lắng nghe các yêu cầu kết nối từ phía máy khách.","iii-phía-máy-khách-client#III. Phía Máy Khách (Client)":"Máy khách chủ động tạo kết nối tới máy chủ.","iv-quy-trình-giao-tiếp-tcp-cơ-bản#IV. Quy Trình Giao Tiếp TCP Cơ Bản":"Giao tiếp bằng Socket thường tuân theo các bước sau:\nBước Server Client 1. Khởi tạo Tạo ServerSocket và lắng nghe Port. Tạo Socket với IP và Port của Server. 2. Kết nối Dùng accept() để chấp nhận kết nối. Kết nối được thiết lập. 3. Trao đổi Dữ liệu Lấy InputStream và OutputStream từ clientSocket. Lấy InputStream và OutputStream từ socket. 4. Đóng kết nối Đóng clientSocket và serverSocket. Đóng socket.","v-kết-luận#V. Kết Luận":"Lập trình Socket là bước đầu tiên và cơ bản nhất để xây dựng các ứng dụng client-server."},"title":"LẬP TRÌNH SOCKET"},"/MyBlog/posts/bai9_da-luong/":{"data":{"":"","1-triển-khai-giao-diện-runnable#1. Triển khai Giao diện \u003ccode\u003eRunnable\u003c/code\u003e":"Đây là cách được khuyến khích vì nó cho phép lớp của bạn kế thừa các lớp khác nếu cần (Java không đa kế thừa).\nĐịnh nghĩa một lớp triển khai giao diện Runnable. Triển khai phương thức run(). Tạo đối tượng Thread và truyền đối tượng Runnable vào. Gọi phương thức start() của đối tượng Thread. public class TaskA implements Runnable { @Override public void run() { System.out.println(\"Luồng Task A đang chạy...\"); } } public static void main(String[] args) { TaskA task = new TaskA(); Thread luongMoi = new Thread(task); luongMoi.start(); // Gọi start() để JVM tạo luồng và gọi run() }","2-kế-thừa-lớp-thread#2. Kế thừa Lớp Thread":"Định nghĩa một lớp kế thừa lớp Thread.\nGhi đè phương thức run().\n3 .Tạo đối tượng của lớp đó và gọi start().\npublic class TaskB extends Thread { @Override public void run() { System.out.println(\"Luồng Task B đang chạy...\"); } } public static void main(String[] args) { TaskB luongB = new TaskB(); luongB.start(); }","i-giới-thiệu-đa-luồng-multithreading#I. Giới Thiệu Đa Luồng (Multithreading)":"Trong thực tế, nhiều chương trình cần xử lý đồng thời nhiều tác vụ (ví dụ: vừa tải ảnh, vừa phát nhạc, vừa phản hồi thao tác người dùng). Đa luồng là khả năng cho phép chương trình thực thi nhiều phần của code (gọi là luồng - Thread) một cách đồng thời (concurrently).\nProcess (Tiến trình): Một ứng dụng hoặc chương trình đang chạy. Mỗi tiến trình có không gian bộ nhớ riêng. Thread (Luồng): Một đơn vị thực thi nhỏ nhất trong một Process. Các luồng trong cùng một Process chia sẻ cùng không gian bộ nhớ.","ii-các-cách-tạo-luồng-threads#II. Các Cách Tạo Luồng (Threads)":"Có hai cách chính để tạo và chạy một luồng trong Java:","iii-các-phương-thức-điều-khiển-luồng#III. Các Phương Thức Điều Khiển Luồng":"Phương thức Công dụng start() Bắt đầu thực thi luồng bằng cách gọi run(). run() Chứa logic chính của luồng. sleep(ms) Tạm dừng luồng trong một khoảng thời gian (miligiây). join() Chờ luồng khác kết thúc công việc của nó. isAlive() Kiểm tra xem luồng còn đang hoạt động hay không. public static void main(String[] args) { Thread luong = new TaskB(); luong.start(); try { // Main thread sẽ chờ luong kết thúc luong.join(); System.out.println(\"Luồng Task B đã hoàn thành.\"); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }","iv-đồng-bộ-hóa-synchronization#IV. Đồng Bộ Hóa (Synchronization)":"Khi nhiều luồng cùng truy cập và thay đổi cùng một tài nguyên (ví dụ: một biến chung), có thể dẫn đến điều kiện chạy đua (Race Condition) và dữ liệu không nhất quán. Đồng bộ hóa giải quyết vấn đề này.\nTừ khóa synchronized: Khi áp dụng cho một phương thức hoặc khối lệnh, nó đảm bảo rằng tại một thời điểm, chỉ có duy nhất một luồng được phép truy cập khối code đó.\npublic class Counter { private int count = 0; // Phương thức được đồng bộ hóa public synchronized void tangGiaTri() { count++; // Đảm bảo việc tăng giá trị diễn ra nguyên tử (atomic) } // ... }","v-kết-luận#V. Kết Luận":"Lập trình đa luồng là một chủ đề phức tạp nhưng cần thiết để xây dựng các ứng dụng hiện đại, phản hồi nhanh. Nắm vững việc tạo luồng và đồng bộ hóa là chìa khóa."},"title":"LẬP TRÌNH ĐA LUỒNG (MULTITHREADING)"}}